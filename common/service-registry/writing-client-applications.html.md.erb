---
title: Writing Client Applications
owner: Spring Cloud Services
---

<strong><%= modified_date %></strong>

_Refer to the sample applications in the <a href="https://github.com/spring-cloud-services-samples/greeting/tree/1.5.x">"greeting" repository</a> to follow along with the code in this topic._

To use a Spring Boot app as a client for a Service Registry instance, you must add the dependencies listed below.

<%= partial '../general-dependencies' %>

Your app must also declare the Spring Cloud Services Service Registry starter as a dependency.

<%= partial '../service-registry-dependency' %>

<% if vars.product_name == 'PCF' %>
 <%= partial vars.scs_sr_self_signed_ssl %>
<% end %>

## <a id="register-a-service"></a>Register a Service

To register with a Service Registry service instance, your application must <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/message-generation/src/main/java/message_generation/MessageGenerationApplication.java#L13-L16">include the ```@EnableDiscoveryClient``` annotation on a configuration class</a>.

```java
@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class MessageGenerationApplication {
    //...
```

The application's Eureka instance name (the name by which it will be registered in Eureka) will be derived from the value of the ```spring.application.name``` property on the application. If you do not provide a value for this property, the application's Eureka instance name will be derived from its Cloud Foundry application name, as set in `manifest.yml`:

```yml
---
instances: 1
memory: 1G
applications:
  - name: message-generation
  ...
```

Set the `spring.application.name` property in <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/message-generation/src/main/resources/application.yml#L1-L3">`application.yml`</a>:

```yml
spring:
  application:
    name: message-generation
```

<p class='note'><strong>Note</strong>: If the application name contains characters which are invalid in a hostname, the application will be registered with the Service Registry service instance using the application name with each invalid character replaced by a hyphen (<code>-</code>) character (for example, given an application name of "message_generation", the Eureka application name used to register the application with the Service Registry service instance will be <code>message-generation</code>). See the <a href="/spring-cloud-services/service-registry/connectors.html#eureka-application-name-configuration">Eureka Application Name Configuration</a> section of the <a href="/spring-cloud-services/service-registry/connectors.html">Spring Cloud Connectors</a> topic for more information.</p>

### <a id="register-using-c2c"></a>Register Using Container-to-Container Networking

To use Cloud Foundry's container networking (see the [Understanding Container-to-Container Networking](https://docs.pivotal.io/pivotalcf/concepts/understand-cf-networking.html) topic in the [Pivotal Cloud Foundry](https://docs.pivotal.io/pivotalcf/) documentation) with the application, your `application.yml` must specify a `spring.cloud.services.registrationMethod` of `direct`.

```yml
spring:
  application:
    name: message-generation
  cloud:
    services:
      registrationMethod: direct
```

Before a client application can use the Service Registry to reach this directly-registered application, you must add a network policy that allows traffic from the client application to this application. See the [Consume Using Container-to-Container Networking](/spring-cloud-services/service-registry/writing-client-applications.html#consume-using-c2c) section for more information.

## <a id="consume-a-service"></a>Consume a Service

Follow the below instructions to consume a service that is registered with a Service Registry service instance.

### <a id="discover-and-consume-a-service-using-resttemplate"></a>Discover and Consume a Service Using RestTemplate

A consuming application must <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/greeter/src/main/java/greeter/GreeterApplication.java#L22-L34">include the ```@EnableDiscoveryClient``` annotation on a configuration class</a>.

```java
@SpringBootApplication
@EnableDiscoveryClient
@RestController
public class GreeterApplication {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

    @Autowired
    private RestTemplate rest;
    //...
```

To call a registered service, a consuming application can use a URI with a hostname matching the name with which the service is registered in the Service Registry. This way, the consuming application does not need to know the service application's actual URL; the Registry will take care of finding and routing to the service.

<p class='note'><strong>Note</strong>: If the name of the registered application contains characters which are invalid in a hostname, that application will be registered with the Service Registry service instance using the application name with each invalid character replaced by a hyphen (<code>-</code>) character. For example, given an application name of "message_generation", the Eureka application name used to register the application with the Service Registry service instance will be <code>message-generation</code>. See the <a href="/spring-cloud-services/service-registry/connectors.html#eureka-application-name-configuration">Eureka Application Name Configuration</a> section of the <a href="/spring-cloud-services/service-registry/connectors.html">Spring Cloud Connectors</a> topic for more information.</p>

By default, Service Registry requires HTTPS for access to registered services. If your client application is consuming a service application which has been registered with the Service Registry instance using route registration (see the <a href="/spring-cloud-services/service-registry/writing-client-applications.html#register-the-application">Register the Application</a> section above), you can use a schemeless URI (as `//message-generation`) to access the service. Spring Cloud Netflix Ribbon will default to using an HTTPS route if one is available and to an HTTP route otherwise. (This behavior requires Spring Cloud Brixton.SR6 or later.)

The Message Generation application is registered with the Service Registry instance as ```message-generation```, so in the Greeter application, <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/greeter/src/main/java/greeter/GreeterApplication.java#L40-L50">the `hello()` method on the `GreeterApplication` class</a> uses the base URI ```//message-generation``` to get a greeting message from Message Generation.

```java
    @RequestMapping(value = "/hello", method = RequestMethod.GET)
    public String hello(@RequestParam(value="salutation",
                                        defaultValue="Hello") String salutation,
                        @RequestParam(value="name",
                                        defaultValue="Bob") String name) {
        URI uri = UriComponentsBuilder.fromUriString("//message-generation/greeting")
            .queryParam("salutation", salutation)
            .queryParam("name", name)
            .build()
            .toUri();

        Greeting greeting = rest.getForObject(uri, Greeting.class);
        return greeting.getMessage();
    }
```

### <a id="discover-and-consume-a-service-using-feign"></a>Discover and Consume a Service Using Feign

If you wish to use [Feign](https://github.com/Netflix/feign) to consume a service that is registered with a Service Registry instance, your application must declare ```spring-cloud-starter-feign``` as a dependency. In order to have Feign client interfaces automatically configured, it must also use the ```@EnableFeignClients``` annotation.

Your consuming application must <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/feign-greeter/src/main/java/greeter/GreeterApplication.java#L18-L25">include the ```@EnableDiscoveryClient``` annotation on a configuration class</a>. In the Greeter application, the ```GreeterApplication``` class contains a ```MessageGenerationClient``` interface, which is a Feign client for the Message Generation application.

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
@RestController
public class GreeterApplication {

    @Autowired
    MessageGenerationClient messageGeneration;
    //...
```

To call a registered service, a consuming application can use a URI with a hostname matching the name with which the service is registered in the Service Registry. This way, the consuming application does not need to know the service application's actual URL; the Registry will take care of finding and routing to the service.

<p class='note'><strong>Note</strong>: If the name of the registered application contains characters which are invalid in a hostname, that application will be registered with the Service Registry service instance using the application name with each invalid character replaced by a hyphen (<code>-</code>) character. For example, given an application name of "message_generation", the Eureka application name used to register the application with the Service Registry service instance will be <code>message-generation</code>. See the <a href="/spring-cloud-services/service-registry/connectors.html#eureka-application-name-configuration">Eureka Application Name Configuration</a> section of the <a href="/spring-cloud-services/service-registry/connectors.html">Spring Cloud Connectors</a> topic for more information.</p>

The Message Generation application is registered with the Service Registry instance as ```message-generation```, so the ```@FeignClient``` annotation on the <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/feign-greeter/src/main/java/greeter/GreeterApplication.java#L52-L56">```MessageGenerationClient``` interface</a> uses the base URI ```http://message-generation```. The interface declares one method, ```greeting()```, which accesses the Message Generation application's ```/greeting``` endpoint and sends along optional ```name``` and ```salutation``` parameters if they are provided.

```java
    @FeignClient("http://message-generation")
    interface MessageGenerationClient {
      @RequestMapping(value = "/greeting", method = GET)
      Greeting greeting(@RequestParam("name") String name, @RequestParam("salutation") String salutation);
    }
```

### <a id="consume-using-c2c"></a>Consume Using Container-to-Container Networking

To use Cloud Foundry's container networking (see the [Understanding Container-to-Container Networking](https://docs.pivotal.io/pivotalcf/concepts/understand-cf-networking.html) topic in the [Pivotal Cloud Foundry](https://docs.pivotal.io/pivotalcf/) documentation) to reach an application registered with the Service Registry, you must add a network policy. You can do this using the Cloud Foundry Command Line Interface (cf CLI).

<p class='note'><strong>Note</strong>: Container networking support is included in the cf CLI version 6.30.0 and later.</p>

Run the `cf network-policies` command to list current network policies:

<pre class="terminal">
$ cf network-policies
Listing network policies in org myorg / space dev as user...

source   destination   protocol   ports
</pre>

Use the `cf add-network-policy` command to grant access from the Greeter application to the Message Generation application:

<pre class="terminal">
$ cf add-network-policy greeter --destination-app message-generation --protocol tcp --port 8080
Adding network policy to app greeter in org myorg / space dev as user...
OK
</pre>

Use `cf network-policies` again to view the new access policy:

<pre class="terminal">
$ cf network-policies
Listing network policies in org myorg / space dev as user...

source    destination          protocol   ports
greeter   message-generation   tcp        8080
</pre>

The Greeter application can now use container networking to access the Message Generation application via the Service Registry. For more information about configuring container networking, see the [Administering Container-to-Container Networking](https://docs.pivotal.io/pivotalcf/devguide/deploy-apps/cf-networking.html) topic in the [Pivotal Cloud Foundry](https://docs.pivotal.io/pivotalcf/) documentation.

## <a id="disable-http-basic-auth"></a>Disable HTTP Basic Authentication

The Spring Cloud Services Starter for Service Registry has a dependency on <a href="https://projects.spring.io/spring-security/">Spring Security</a>. Unless your application has other security configuration, this will cause all application endpoints to be protected by HTTP Basic authentication.

If you do not yet want to address application security, you can disable Basic authentication. See below for information about doing this in your app's version of Spring Boot.

### Using Spring Boot 1.5

If you are using Spring Boot 1.5, you can disable HTTP Basic authentication by setting the `security.basic.enabled` property to `false` in <a href="https://github.com/spring-cloud-services-samples/greeting/blob/1.5.x/greeter/src/main/resources/bootstrap.yml#L17-L23">`bootstrap.yml`</a> or `application.yml`. You might make this setting specific to a profile (such as the `dev` profile if you want Basic authentication disabled only for development):

```yml
---
spring:
  profiles: dev

security:
  basic:
    enabled: false
```

For more information, see ["Security" in the Spring Boot 1.5 Reference Guide](https://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#boot-features-security).

<p class='note'><strong>Note</strong>: Because of the Spring Security dependency, HTTPS Basic authentication will also be enabled for Spring Boot Actuator endpoints. If you wish to disable that as well, you must also set the <code>management.security.enabled</code> property to <code>false</code>. See <a href="https://docs.spring.io/spring-boot/docs/1.5.x/reference/htmlsingle/#production-ready-customizing-management-server-port">"Customizing the management server port" in the Spring Boot 1.5 Reference Guide</a>.</p>

### Using Spring Boot 2.0

If you are using Spring Boot 2.0, you can disable HTTP Basic authentication using a class that extends Spring Security's `WebSecurityConfigurerAdapter` and is annotated with the Spring `@Configuration` annotation. To do so, you must include the Spring Boot Security starter in your build file.

Using Maven:

```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

Using Gradle:

```
compile("org.springframework.boot:spring-boot-starter-security")
```

The following class disables all default security for the `development` profile only, using the `@Profile` annotation:

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@Profile("development")
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
				.authorizeRequests().anyRequest().permitAll()
				.and()
				.httpBasic().disable()
				.csrf().disable();
	}

}
```

For more information, see ["Security" in the Spring Boot 2.0 Reference Guide](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-security).
